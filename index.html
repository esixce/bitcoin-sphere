<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>secp256k1 on the projective sphere</title>
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
</head>
<body>
  <div style="margin:0.5em 1em; font-family:sans-serif;">
    <label for="pubkeys">Public keys (hex, one per line — 66 or 130 chars):</label><br>
    <textarea id="pubkeys" rows="4" style="width:100%; max-width:720px; font-family:monospace; font-size:12px;" placeholder="02... or 04..."></textarea><br>
    <button type="button" id="showBtn">Show on sphere</button>
    <span id="msg" style="margin-left:0.5em; color:#c00;"></span>
    <label style="display:block; margin-top:0.5em;"><input type="checkbox" id="earthLayer" checked> Earth layer (North = mathematical pole, Greenwich = symmetry line)</label>
  </div>
  <div id="plot" style="width:100%; height:700px;"></div>
  <p style="margin:0.5em 1em; font-family:sans-serif;">
    secp256k1 on the projective sphere — G and 100 points (kG for k = 1…100). Paste your keys above to see where you are. Drag to rotate.
  </p>
  <div style="margin:1em 1em 2em; font-family:sans-serif; font-size:14px;">
    <strong>Sample pubkeys to try</strong> (copy into the box above, then click Show on sphere):
    <ul style="margin:0.25em 0; padding-left:1.25em;">
      <li><strong>Generator G</strong> (compressed) — the secp256k1 generator point used by every Bitcoin node:<br>
        <code style="font-size:11px; word-break:break-all;">0279BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798</code></li>
      <li><strong>Genesis block coinbase</strong> (uncompressed) — the 50 BTC output in block 0 (address 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa):<br>
        <code style="font-size:11px; word-break:break-all;">04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f</code></li>
      <li><strong>2G</strong> (compressed) — second point on the curve (2 × generator):<br>
        <code style="font-size:11px; word-break:break-all;">02C6047F9441ED7D6D3045406E95C07CD85C778E4B8CEF3CA7ABAC09B95C709EE5</code></li>
    </ul>
  </div>
  <script src="sphere-math.js"></script>
  <script>
    (function () {
      const M = window.sphereMath;
      const span = 2 * Math.PI;
      const nFill = 50;
      const fillV = [];
      for (let i = 0; i <= nFill; i++) fillV.push(-span + (2 * span * i) / nFill);

      function invStereo(u, v) {
        const d = u * u + v * v + 1;
        return { x: 2 * u / d, y: 2 * v / d, z: (u * u + v * v - 1) / d };
      }

      const xs = [], ys = [], zs = [];
      for (let i = 0; i <= nFill; i++) {
        const rowX = [], rowY = [], rowZ = [];
        for (let j = 0; j <= nFill; j++) {
          const u = fillV[j], v = fillV[i];
          const p = invStereo(u, v);
          rowX.push(p.x); rowY.push(p.y); rowZ.push(p.z);
        }
        xs.push(rowX); ys.push(rowY); zs.push(rowZ);
      }

      // Earth layer: same unit sphere, north pole = (0,0,1), Greenwich = positive X (lon 0)
      function lonLatFromXYZ(x, y, z) {
        var lon = Math.atan2(y, x);
        var lat = Math.asin(Math.max(-1, Math.min(1, z)));
        return { lon: lon, lat: lat };
      }
      function earthSurfaceColor(lon, lat) {
        var t = 0.5 + 0.25 * Math.sin(lat * 2) * Math.sin(lon * 3) + 0.2 * Math.sin(lat * 7) * Math.cos(lon * 5) + 0.15 * Math.cos(lat * 4) * Math.sin(lon * 6);
        t = (t - 0.2) / 0.8;
        t = Math.max(0, Math.min(1, t));
        return t;
      }
      const earthColors = [];
      for (var ei = 0; ei <= nFill; ei++) {
        const row = [];
        for (var ej = 0; ej <= nFill; ej++) {
          var x = xs[ei][ej], y = ys[ei][ej], z = zs[ei][ej];
          var ll = lonLatFromXYZ(x, y, z);
          row.push(earthSurfaceColor(ll.lon, ll.lat));
        }
        earthColors.push(row);
      }
      const earthTrace = {
        x: xs, y: ys, z: zs,
        surfacecolor: earthColors,
        colorscale: [[0, 'rgb(20,70,140)'], [0.35, 'rgb(90,160,220)'], [0.5, 'rgb(70,130,70)'], [0.7, 'rgb(140,120,80)'], [1, 'rgb(80,90,50)']],
        showscale: false,
        opacity: 0.92,
        type: 'surface',
        name: 'Earth (toggle)',
      };

      const surfaceTrace = {
        x: xs, y: ys, z: zs,
        surfacecolor: zs,
        colorscale: 'Viridis',
        showscale: false,
        opacity: 0.4,
        type: 'surface',
      };

      const sampleX = [], sampleY = [], sampleZ = [];
      const G = M.G;
      for (let k = 1; k <= 100; k++) {
        const pt = M.scalarMult(BigInt(k), G);
        if (pt) {
          const s = M.pointToSphere(pt.x, pt.y);
          sampleX.push(s.x); sampleY.push(s.y); sampleZ.push(s.z);
        }
      }

      const sampleTrace = {
        x: sampleX, y: sampleY, z: sampleZ,
        mode: 'markers',
        type: 'scatter3d',
        marker: { size: 2.5, color: 'rgb(255,34,0)', opacity: 0.85 },
        name: 'kG (k = 1…100)',
      };

      const gSphere = M.pointToSphere(G.x, G.y);
      const gTrace = {
        x: [gSphere.x], y: [gSphere.y], z: [gSphere.z],
        mode: 'markers+text',
        type: 'scatter3d',
        marker: { size: 10, color: 'gold', symbol: 'diamond', line: { color: 'black', width: 2 } },
        text: ['  G (generator)'],
        textposition: 'top right',
        name: 'G — Bitcoin generator',
      };

      const oTrace = {
        x: [0], y: [0], z: [1.05],
        mode: 'markers+text',
        type: 'scatter3d',
        marker: { size: 8, color: 'white', line: { color: 'red', width: 3 } },
        text: ['  O (point at infinity)'],
        textposition: 'top right',
        name: 'O',
      };

      const layout = {
        title: 'secp256k1: y² = x³ + 7 — projective sphere',
        scene: {
          xaxis: { title: 'X' },
          yaxis: { title: 'Y' },
          zaxis: { title: 'Z' },
          aspectmode: 'data',
          camera: { eye: { x: 1.8, y: 0, z: 0.6 } },
        },
        height: 700,
        margin: { l: 0, r: 0, t: 40, b: 0 },
        legend: { x: 0.01, y: 0.98 },
      };

      var earthLayerVisible = true;
      function baseTracesWithEarth() {
        var list = [surfaceTrace, sampleTrace, gTrace, oTrace];
        if (earthLayerVisible) list.unshift(earthTrace);
        return list;
      }

      function buildUserTrace() {
        const raw = document.getElementById('pubkeys').value;
        const lines = raw.split(/\r?\n/).map(function (s) { return s.replace(/\s/g, ''); }).filter(Boolean);
        const msgEl = document.getElementById('msg');
        const ux = [], uy = [], uz = [], labels = [];
        const errors = [];

        for (let i = 0; i < lines.length; i++) {
          const hex = lines[i];
          try {
            const pt = M.parsePubkey(hex);
            const s = M.pointToSphere(pt.x, pt.y);
            ux.push(s.x); uy.push(s.y); uz.push(s.z);
            labels.push('Your key ' + (i + 1));
          } catch (e) {
            errors.push('Key ' + (i + 1) + ': ' + (e.message || String(e)));
          }
        }

        if (errors.length) {
          msgEl.textContent = errors.length + ' invalid: ' + errors.slice(0, 2).join('; ') + (errors.length > 2 ? '…' : '');
          msgEl.style.color = '#c00';
        } else if (ux.length === 0) {
          msgEl.textContent = 'Enter one or more public keys (66 or 130 hex chars).';
          msgEl.style.color = '#666';
        } else {
          msgEl.textContent = ux.length + ' key(s) on sphere.';
          msgEl.style.color = '#060';
        }

        if (ux.length === 0) return null;
        return {
          x: ux, y: uy, z: uz,
          mode: 'markers+text',
          type: 'scatter3d',
          marker: { size: 8, color: 'rgb(0,150,255)', symbol: 'circle-open', line: { color: 'rgb(0,100,200)', width: 2 } },
          text: labels.map(function (l) { return '  ' + l; }),
          textposition: 'top right',
          name: 'Your keys',
        };
      }

      function redraw() {
        const userTrace = buildUserTrace();
        const base = baseTracesWithEarth();
        const traces = userTrace ? base.concat([userTrace]) : base;
        Plotly.react('plot', traces, layout);
      }

      document.getElementById('earthLayer').addEventListener('change', function() {
        earthLayerVisible = this.checked;
        redraw();
      });

      Plotly.newPlot('plot', baseTracesWithEarth(), layout);
      document.getElementById('showBtn').addEventListener('click', redraw);
    })();
  </script>
</body>
</html>
