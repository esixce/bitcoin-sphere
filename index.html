<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>secp256k1 on the projective sphere</title>
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
</head>
<body>
  <div style="margin:0.5em 1em; font-family:sans-serif;">
    <label for="pubkeys">Public keys (hex, one per line — 66 or 130 chars):</label><br>
    <textarea id="pubkeys" rows="4" style="width:100%; max-width:720px; font-family:monospace; font-size:12px;" placeholder="02... or 04..."></textarea><br>
    <button type="button" id="showBtn">Show on sphere</button>
    <span id="msg" style="margin-left:0.5em; color:#c00;"></span>
    <label style="display:block; margin-top:0.5em;"><input type="checkbox" id="earthLayer" checked> Earth layer (North = mathematical pole, Greenwich = symmetry line)</label>
    <span id="earthStatus" style="margin-left:0.5em; color:#666; font-size:12px;"></span>
    <label style="display:block; margin-top:0.5em;">Max k: <input type="number" id="maxK" min="1" max="500" value="100" style="width:4em;"> (kG for k = 1…max)</label>
    <label style="display:block; margin-top:0.25em;"><input type="checkbox" id="reflectY"> Also show y-axis reflection of kG points</label>
  </div>
  <div id="plot" style="width:100%; height:700px;"></div>
  <p style="margin:0.5em 1em; font-family:sans-serif;">
    secp256k1 on the projective sphere — G and kG points (k = 1…max k; optional y-axis reflection). Paste your keys above to see where you are. Drag to rotate.
  </p>
  <div style="margin:1em 1em 2em; font-family:sans-serif; font-size:14px;">
    <strong>Sample pubkeys to try</strong> (copy into the box above, then click Show on sphere):
    <ul style="margin:0.25em 0; padding-left:1.25em;">
      <li><strong>Generator G</strong> (compressed) — the secp256k1 generator point used by every Bitcoin node:<br>
        <code style="font-size:11px; word-break:break-all;">0279BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798</code></li>
      <li><strong>Genesis block coinbase</strong> (uncompressed) — the 50 BTC output in block 0 (address 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa):<br>
        <code style="font-size:11px; word-break:break-all;">04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f</code></li>
      <li><strong>2G</strong> (compressed) — second point on the curve (2 × generator):<br>
        <code style="font-size:11px; word-break:break-all;">02C6047F9441ED7D6D3045406E95C07CD85C778E4B8CEF3CA7ABAC09B95C709EE5</code></li>
    </ul>
  </div>
  <script src="sphere-math.js"></script>
  <script>
    (function () {
      const M = window.sphereMath;
      const span = 2 * Math.PI;
      const nFill = 50;
      const fillV = [];
      for (let i = 0; i <= nFill; i++) fillV.push(-span + (2 * span * i) / nFill);

      function invStereo(u, v) {
        const d = u * u + v * v + 1;
        return { x: 2 * u / d, y: 2 * v / d, z: (u * u + v * v - 1) / d };
      }

      const xs = [], ys = [], zs = [];
      for (let i = 0; i <= nFill; i++) {
        const rowX = [], rowY = [], rowZ = [];
        for (let j = 0; j <= nFill; j++) {
          const u = fillV[j], v = fillV[i];
          const p = invStereo(u, v);
          rowX.push(p.x); rowY.push(p.y); rowZ.push(p.z);
        }
        xs.push(rowX); ys.push(rowY); zs.push(rowZ);
      }

      // Earth layer: same unit sphere, north pole = (0,0,1), Greenwich = positive X (lon 0)
      function lonLatFromXYZ(x, y, z) {
        var lon = Math.atan2(y, x);
        var lat = Math.asin(Math.max(-1, Math.min(1, z)));
        return { lon: lon, lat: lat };
      }
      function earthSurfaceColorProcedural(lon, lat) {
        var t = 0.5 + 0.25 * Math.sin(lat * 2) * Math.sin(lon * 3) + 0.2 * Math.sin(lat * 7) * Math.cos(lon * 5) + 0.15 * Math.cos(lat * 4) * Math.sin(lon * 6);
        t = (t - 0.2) / 0.8;
        return Math.max(0, Math.min(1, t));
      }
      const earthColorsProcedural = [];
      for (var ei = 0; ei <= nFill; ei++) {
        const row = [];
        for (var ej = 0; ej <= nFill; ej++) {
          var x = xs[ei][ej], y = ys[ei][ej], z = zs[ei][ej];
          var ll = lonLatFromXYZ(x, y, z);
          row.push(earthSurfaceColorProcedural(ll.lon, ll.lat));
        }
        earthColorsProcedural.push(row);
      }
      var earthTrace = {
        x: xs, y: ys, z: zs,
        surfacecolor: earthColorsProcedural,
        colorscale: [[0, 'rgb(20,70,140)'], [0.35, 'rgb(90,160,220)'], [0.5, 'rgb(70,130,70)'], [0.7, 'rgb(140,120,80)'], [1, 'rgb(80,90,50)']],
        showscale: false,
        opacity: 0.92,
        type: 'surface',
        name: 'Earth (toggle)',
      };

      function setEarthStatus(text) {
        var el = document.getElementById('earthStatus');
        if (el) el.textContent = text;
      }

      function buildEarthTraceFromImage(img) {
        var w = img.naturalWidth || img.width, h = img.naturalHeight || img.height;
        if (!w || !h) return;
        var canvas = document.createElement('canvas');
        canvas.width = w;
        canvas.height = h;
        var ctx = canvas.getContext('2d');
        var data;
        try {
          ctx.drawImage(img, 0, 0);
          data = ctx.getImageData(0, 0, w, h).data;
        } catch (e) {
          if (e.name === 'SecurityError' || (e.message && e.message.indexOf('tainted') !== -1)) {
            setEarthStatus('Earth texture: procedural (open via a server, e.g. npx serve .)');
          } else {
            setEarthStatus('Earth texture: error');
            console.error('Earth texture:', e);
          }
          return;
        }
        var sampled = [];
        var earthColorsNew = [];
        for (var ei = 0; ei <= nFill; ei++) {
          var row = [];
          for (var ej = 0; ej <= nFill; ej++) {
            var x = xs[ei][ej], y = ys[ei][ej], z = zs[ei][ej];
            var ll = lonLatFromXYZ(x, y, z);
            var u = (ll.lon + Math.PI) / (2 * Math.PI);
            var v = 0.5 - ll.lat / Math.PI;
            var px = Math.floor(u * w) % w;
            if (px < 0) px += w;
            var py = Math.max(0, Math.min(h - 1, Math.floor(v * h)));
            var i = (py * w + px) * 4;
            var r = data[i], g = data[i + 1], b = data[i + 2];
            sampled.push([r, g, b]);
            row.push(0);
          }
          earthColorsNew.push(row);
        }
        var N = (nFill + 1) * (nFill + 1);
        var scaleVal = N <= 1 ? 1 : N - 1;
        for (var ei = 0; ei <= nFill; ei++) {
          for (var ej = 0; ej <= nFill; ej++) {
            earthColorsNew[ei][ej] = (ei * (nFill + 1) + ej) / scaleVal;
          }
        }
        var colorscale = [];
        for (var idx = 0; idx < sampled.length; idx++) {
          var rgb = sampled[idx];
          colorscale.push([idx / scaleVal, 'rgb(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ')']);
        }
        if (colorscale.length === 0) colorscale = [[0, 'rgb(20,70,140)']];
        earthTrace = {
          x: xs, y: ys, z: zs,
          surfacecolor: earthColorsNew,
          colorscale: colorscale,
          showscale: false,
          opacity: 0.92,
          type: 'surface',
          name: 'Earth (toggle)',
        };
        setEarthStatus('Earth texture: map');
        redraw();
      }

      var earthImg = new Image();
      earthImg.crossOrigin = 'anonymous';
      earthImg.onload = function() {
        setEarthStatus('Earth texture: applying…');
        buildEarthTraceFromImage(earthImg);
      };
      earthImg.onerror = function() {
        setEarthStatus('Earth texture: procedural (image failed to load)');
      };
      setEarthStatus('Earth texture: loading…');
      earthImg.src = 'Equirectangular-projection.jpg';

      const surfaceTrace = {
        x: xs, y: ys, z: zs,
        surfacecolor: zs,
        colorscale: 'Viridis',
        showscale: false,
        opacity: 0.4,
        type: 'surface',
      };

      const G = M.G;
      const maxKCap = 500;
      function buildSampleTrace() {
        var maxK = parseInt(document.getElementById('maxK').value, 10);
        if (isNaN(maxK) || maxK < 1) maxK = 1;
        if (maxK > maxKCap) maxK = maxKCap;
        var reflectY = document.getElementById('reflectY').checked;
        var sampleX = [], sampleY = [], sampleZ = [];
        for (var k = 1; k <= maxK; k++) {
          var pt = M.scalarMult(BigInt(k), G);
          if (pt) {
            var s = M.pointToSphere(pt.x, pt.y);
            sampleX.push(s.x); sampleY.push(s.y); sampleZ.push(s.z);
            if (reflectY) {
              sampleX.push(-s.x); sampleY.push(s.y); sampleZ.push(s.z);
            }
          }
        }
        var name = 'kG (k = 1…' + maxK + (reflectY ? ', incl. reflection' : '') + ')';
        return {
          x: sampleX, y: sampleY, z: sampleZ,
          mode: 'markers',
          type: 'scatter3d',
          marker: { size: 2.5, color: 'rgb(255,34,0)', opacity: 0.85 },
          name: name,
        };
      }

      const gSphere = M.pointToSphere(G.x, G.y);
      const gTrace = {
        x: [gSphere.x], y: [gSphere.y], z: [gSphere.z],
        mode: 'markers+text',
        type: 'scatter3d',
        marker: { size: 10, color: 'gold', symbol: 'diamond', line: { color: 'black', width: 2 } },
        text: ['  G (generator)'],
        textposition: 'top right',
        name: 'G — Bitcoin generator',
      };

      const oTrace = {
        x: [0], y: [0], z: [1.05],
        mode: 'markers+text',
        type: 'scatter3d',
        marker: { size: 8, color: 'white', line: { color: 'red', width: 3 } },
        text: ['  O (point at infinity)'],
        textposition: 'top right',
        name: 'O',
      };

      const layout = {
        title: 'secp256k1: y² = x³ + 7 — projective sphere',
        scene: {
          xaxis: { title: 'X' },
          yaxis: { title: 'Y' },
          zaxis: { title: 'Z' },
          aspectmode: 'data',
          camera: { eye: { x: 1.8, y: 0, z: 0.6 } },
        },
        height: 700,
        margin: { l: 0, r: 0, t: 40, b: 0 },
        legend: { x: 0.01, y: 0.98 },
      };

      var earthLayerVisible = true;
      function baseTracesWithEarth() {
        var list = [surfaceTrace, buildSampleTrace(), gTrace, oTrace];
        if (earthLayerVisible) list.unshift(earthTrace);
        return list;
      }

      function buildUserTrace() {
        const raw = document.getElementById('pubkeys').value;
        const lines = raw.split(/\r?\n/).map(function (s) { return s.replace(/\s/g, ''); }).filter(Boolean);
        const msgEl = document.getElementById('msg');
        const ux = [], uy = [], uz = [], labels = [];
        const errors = [];

        for (let i = 0; i < lines.length; i++) {
          const hex = lines[i];
          try {
            const pt = M.parsePubkey(hex);
            const s = M.pointToSphere(pt.x, pt.y);
            ux.push(s.x); uy.push(s.y); uz.push(s.z);
            labels.push('Your key ' + (i + 1));
          } catch (e) {
            errors.push('Key ' + (i + 1) + ': ' + (e.message || String(e)));
          }
        }

        if (errors.length) {
          msgEl.textContent = errors.length + ' invalid: ' + errors.slice(0, 2).join('; ') + (errors.length > 2 ? '…' : '');
          msgEl.style.color = '#c00';
        } else if (ux.length === 0) {
          msgEl.textContent = 'Enter one or more public keys (66 or 130 hex chars).';
          msgEl.style.color = '#666';
        } else {
          msgEl.textContent = ux.length + ' key(s) on sphere.';
          msgEl.style.color = '#060';
        }

        if (ux.length === 0) return null;
        return {
          x: ux, y: uy, z: uz,
          mode: 'markers+text',
          type: 'scatter3d',
          marker: { size: 8, color: 'rgb(0,150,255)', symbol: 'circle-open', line: { color: 'rgb(0,100,200)', width: 2 } },
          text: labels.map(function (l) { return '  ' + l; }),
          textposition: 'top right',
          name: 'Your keys',
        };
      }

      function redraw() {
        const userTrace = buildUserTrace();
        const base = baseTracesWithEarth();
        const traces = userTrace ? base.concat([userTrace]) : base;
        Plotly.react('plot', traces, layout);
      }

      document.getElementById('earthLayer').addEventListener('change', function() {
        earthLayerVisible = this.checked;
        redraw();
      });
      document.getElementById('maxK').addEventListener('change', redraw);
      document.getElementById('maxK').addEventListener('input', redraw);
      document.getElementById('reflectY').addEventListener('change', redraw);

      Plotly.newPlot('plot', baseTracesWithEarth(), layout);
      document.getElementById('showBtn').addEventListener('click', redraw);
    })();
  </script>
</body>
</html>
